## 1.0 实现目标

总结一些开发经验，帮助和自己有着同样经历的同学不断成长

## 2.0 玩转技巧

### 2.1 **non-blocking IO**

- **使用场景:**

    消息推送，但不考虑结果状态

- **代码片段**

    > framework/src/Request.class.php

### 2.2 **Promise**

- **相关简介:**

    Promise中有一个特别好的方法`all`，它可以达到并发的效果，而且写法也很fashion

    一般程序编写的初期采用了同步的方式，那就可以用并行的方式去获取资源，但需要考虑同时发送的请求数

- **使用场景:**

    并发获取资源

- **代码片段**

    > GuzzleHttp/Promise

### 2.3 **Redis pipeline**

- **相关简介:**

    将多条命令一次性发送给服务器然后执行，极大减少了交互的次数

- **使用场景:**

    保存用户信息

- **代码片段**

    > 

### 2.4 **AMQP**

理解Broker的内部实现，包括两部分，exchanger与queue

### 2.5 **MySQL BatchInsert**

批量插入的方式必然更加有效，但在此基础上能不能再有所突破

### 2.6 **Deamon Process**

在处理消息队列中的任务时，采用守护进程的方式处理，但守护进程需要考虑的因素有很多，比如内存溢出，程序退出，优雅重启，避免窗口退出造成进程死掉

### 2.7 **PThread**

多线程程序只能运行在cli模式下，而且其实现与其他语言有很大的不同，多个线程之间不能通过共享内存变量的方式进行通信，因为多线程之间被互相隔离了

### 2.8 **Memory**

如何控制内存的使用率，变量引用，迭代器，GC，重启，限制单个进程的内存使用

### 2.9 **Hooks**

使用钩子可以更好的做到切面编程

### 2.10 **Logger**

Mongologger

### 2.11 **HeapSort**

TopK

### 2.12 **Composer Psr4**

autoload

### 2.13 **Lock**

多个请求同时操纵一个资源，需要加锁

### 2.14 **phptrace**



### 2.15 **Cache-Aside**
### 2.16 **Zookeeper**